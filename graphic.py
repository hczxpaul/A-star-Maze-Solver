__author__ = "Weize Shen"import pygameimport numpyfrom pygame.locals import *from heuristic import *import time# Define the colors we will use in RGB format# White is regular unblock, Red is block, Grey is hard to traverse, Green is unblocked cell with a highway, Blue is hard to traverse cell with a highwayBLACK = (  0,   0,   0)WHITE = (255, 255, 255)BLUE =  (  0,   0, 255)GREEN = (  0, 255,   0)RED =   (255,   0,   0)GREY =  (238, 203, 173)DARK_GREY = (49, 79, 79)# This sets the WIDTH and HEIGHT of each grid locationWIDTH = 8HEIGHT = 8result_file = open('result_file.txt','w')file_start_point = []file_end_point = []file_hard_to_traverse_point = []file_frame = []time_file = open('run_time_file.csv','w')run_time = []file_run_time = []file_cell_length = []cell_length = []file_node_expand = []node_expand = []file_memory_require = []memory_require = []# White cells are unblocked, light gray cells are partially blocked, dark gray cells are blocked# and the blue line indicates a direction of motion along which the motion of the agent can be# accelerateddef init_frame(frame):    frame = [[1 for i in range(160)] for j in range(120)]    return framedef make_graphic(frame,astar):    file_frame = frame    pygame.init()    WINDOW_SIZE = [1560, 960]    screen = pygame.display.set_mode(WINDOW_SIZE)    # Set title of screen    pygame.display.set_caption("Map")    # Loop until the user clicks the close button.    done = False    # Used to manage how fast the screen updates    clock = pygame.time.Clock()    number = 0.75    # Set the screen background    screen.fill(WHITE)    # Draw the grid    for row in range(120):        for column in range(160):            color = BLACK            pygame.draw.rect(screen,color,(WIDTH * column ,HEIGHT * row ,WIDTH,HEIGHT),1)    # Limit to 60 frames per second    clock.tick(60)    # fill color based on 2d array    for x in range(120):        for y in range (160):            if(frame[x][y]==2):                color = GREY            elif(frame[x][y]==0):                color = DARK_GREY            elif(frame[x][y]=='a'):                color = BLUE            elif(frame[x][y]=='b'):                color = BLUE            elif(frame[x][y]==1):                color = WHITE            elif(frame[x][y]=='p' or frame[x][y]=='q' or frame[x][y]=='r' or frame[x][y]=='s'):                color = RED            else:                continue            make_grid_color(screen,color,y*8,x*8)    # Go ahead and update the screen with what we've drawn.    #pygame.display.flip()    pygame.font.init()  # you have to call this at the start,    # if you want to use this module.    myfont = pygame.font.SysFont("Comic Sans MS", 30)    textsurface = myfont.render('Start', False, (0, 0, 0))    screen.blit(textsurface, (1380, 800))    #astar = AsMan(frame)    check = 0    pygame.display.flip()    while not done:        for event in pygame.event.get():  # User did something            if event.type == pygame.QUIT:  # If user clicked close                done = True            if event.type == pygame.MOUSEBUTTONUP:                pos = pygame.mouse.get_pos()                if(pos[0]>=1385 and pos[0]<=1455 and pos[1]>=810 and pos[1]<=835):                    #store start&end position in file                    start_goal_pos = init_start_goal_pos(frame)                    for i in range(10):                        file_start_point.append([start_goal_pos[i*4+0], start_goal_pos[i*4+1]])                    for i in range(10):                        file_end_point.append([start_goal_pos[i*4+2], start_goal_pos[i*4+3]])                    for z in range(240):                        start_time = time.time()                        for x in range(120):                            for y in range(160):                                if (frame[x][y] == 'p'):                                    frame[x][y] = 1                                elif(frame[x][y]=='q'):                                    frame[x][y] = 2                                elif(frame[x][y]=='r'):                                    frame[x][y] = 'a'                                elif(frame[x][y]=='s'):                                    frame[x][y] = 'b'                                else:                                    continue                        grid = frame                        if(z<10):                            astar = UCS(grid)                            frame = astar.search((start_goal_pos[z*4+1], start_goal_pos[z*4+0]),                                                 (start_goal_pos[z*4+3], start_goal_pos[z*4+2]),1)                            cell_length.append(astar.get_cell(start_goal_pos[z*4+3], start_goal_pos[z*4+2]).f)                        elif(z<20):                            astar = AsMan(grid)                            frame = astar.search((start_goal_pos[(z-10)*4+1], start_goal_pos[(z-10)*4+0]),                                                 (start_goal_pos[(z-10)*4+3], start_goal_pos[(z-10)*4+2]),1)                            cell_length.append(astar.get_cell(start_goal_pos[(z-10)*4 + 3], start_goal_pos[(z-10)*4 + 2]).f)                        elif(z<30):                            astar = AsMan(grid)                            frame = astar.search((start_goal_pos[(z-20)*4+1], start_goal_pos[(z-20)*4+0]),                                                 (start_goal_pos[(z-20)*4+3], start_goal_pos[(z-20)*4+2]),1.5)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 20) * 4 + 3], start_goal_pos[(z - 20) * 4 + 2]).f)                        elif(z<40):                            astar = AsMan(grid)                            frame = astar.search((start_goal_pos[(z-30)*4+1], start_goal_pos[(z-30)*4+0]),                                                 (start_goal_pos[(z-30)*4+3], start_goal_pos[(z-30)*4+2]), 2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 30) * 4 + 3], start_goal_pos[(z - 30) * 4 + 2]).f)                        elif(z<50):                            astar = AsCostMan(grid)                            frame = astar.search((start_goal_pos[(z-40)*4+1], start_goal_pos[(z-40)*4+0]),                                                 (start_goal_pos[(z-40)*4+3], start_goal_pos[(z-40)*4+2]),1)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 40) * 4 + 3], start_goal_pos[(z - 40) * 4 + 2]).f)                        elif (z < 60):                            astar = AsCostMan(grid)                            frame = astar.search((start_goal_pos[(z - 50) * 4 + 1], start_goal_pos[(z - 50) * 4 + 0]),                                                 (start_goal_pos[(z - 50) * 4 + 3], start_goal_pos[(z - 50) * 4 + 2]),                                                 1.5)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 50) * 4 + 3], start_goal_pos[(z - 50) * 4 + 2]).f)                        elif (z < 70):                            astar = AsCostMan(grid)                            frame = astar.search((start_goal_pos[(z - 60) * 4 + 1], start_goal_pos[(z - 60) * 4 + 0]),                                                 (start_goal_pos[(z - 60) * 4 + 3], start_goal_pos[(z - 60) * 4 + 2]),2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 60) * 4 + 3], start_goal_pos[(z - 60) * 4 + 2]).f)                        elif (z < 80):                            astar = AsEu(grid)                            frame = astar.search((start_goal_pos[(z - 70) * 4 + 1], start_goal_pos[(z - 70) * 4 + 0]),                                                 (start_goal_pos[(z - 70) * 4 + 3], start_goal_pos[(z - 70) * 4 + 2]),1)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 70) * 4 + 3], start_goal_pos[(z - 70) * 4 + 2]).f)                        elif (z < 90):                            astar = AsEu(grid)                            frame = astar.search((start_goal_pos[(z - 80) * 4 + 1], start_goal_pos[(z - 80) * 4 + 0]),                                                 (start_goal_pos[(z - 80) * 4 + 3], start_goal_pos[(z - 80) * 4 + 2]),1.5)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 80) * 4 + 3], start_goal_pos[(z - 80) * 4 + 2]).f)                        elif (z < 100):                            astar = AsEu(grid)                            frame = astar.search((start_goal_pos[(z - 90) * 4 + 1], start_goal_pos[(z - 90) * 4 + 0]),                                                 (start_goal_pos[(z - 90) * 4 + 3], start_goal_pos[(z - 90) * 4 + 2]),2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 90) * 4 + 3], start_goal_pos[(z - 90) * 4 + 2]).f)                        elif (z < 110):                            astar = AsME(grid)                            frame = astar.search((start_goal_pos[(z - 100) * 4 + 1], start_goal_pos[(z - 100) * 4 + 0]),                                                 (start_goal_pos[(z - 100) * 4 + 3], start_goal_pos[(z - 100) * 4 + 2]),1)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 100) * 4 + 3], start_goal_pos[(z - 100) * 4 + 2]).f)                        elif (z < 120):                            astar = AsME(grid)                            frame = astar.search((start_goal_pos[(z - 110) * 4 + 1], start_goal_pos[(z - 110) * 4 + 0]),                                                 (start_goal_pos[(z - 110) * 4 + 3], start_goal_pos[(z - 110) * 4 + 2]),1.5)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 110) * 4 + 3], start_goal_pos[(z - 110) * 4 + 2]).f)                        elif (z < 130):                            astar = AsME(grid)                            frame = astar.search((start_goal_pos[(z - 120) * 4 + 1], start_goal_pos[(z - 120) * 4 + 0]),                                                 (start_goal_pos[(z - 120) * 4 + 3], start_goal_pos[(z - 120) * 4 + 2]),2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 120) * 4 + 3], start_goal_pos[(z - 120) * 4 + 2]).f)                        elif (z < 140):                            astar = AsDia(grid)                            frame = astar.search((start_goal_pos[(z - 130) * 4 + 1], start_goal_pos[(z - 130) * 4 + 0]),                                                 (start_goal_pos[(z - 130) * 4 + 3], start_goal_pos[(z - 130) * 4 + 2]),1)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 130) * 4 + 3], start_goal_pos[(z - 130) * 4 + 2]).f)                        elif (z < 150):                            astar = AsDia(grid)                            frame = astar.search((start_goal_pos[(z - 140) * 4 + 1], start_goal_pos[(z - 140) * 4 + 0]),                                                 (start_goal_pos[(z - 140) * 4 + 3], start_goal_pos[(z - 140) * 4 + 2]),1.5)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 140) * 4 + 3], start_goal_pos[(z - 140) * 4 + 2]).f)                        elif (z < 160):                            astar = AsDia(grid)                            frame = astar.search((start_goal_pos[(z - 150) * 4 + 1], start_goal_pos[(z - 150) * 4 + 0]),                                                 (start_goal_pos[(z - 150) * 4 + 3], start_goal_pos[(z - 150) * 4 + 2]),2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 150) * 4 + 3], start_goal_pos[(z - 150) * 4 + 2]).f)                        elif (z < 170):                            astar = AsSeq(grid)                            frame = astar.search((start_goal_pos[(z - 160) * 4 + 1], start_goal_pos[(z - 160) * 4 + 0]),                                                 (start_goal_pos[(z - 160) * 4 + 3], start_goal_pos[(z - 160) * 4 + 2]),3,1.25)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 160) * 4 + 3], start_goal_pos[(z - 160) * 4 + 2]).f)                        elif (z < 180):                            astar = AsSeq(grid)                            frame = astar.search((start_goal_pos[(z - 170) * 4 + 1], start_goal_pos[(z - 170) * 4 + 0]),                                                 (start_goal_pos[(z - 170) * 4 + 3], start_goal_pos[(z - 170) * 4 + 2]),3,2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 170) * 4 + 3], start_goal_pos[(z - 170) * 4 + 2]).f)                        elif (z < 190):                            astar = AsSeq(grid)                            frame = astar.search((start_goal_pos[(z - 180) * 4 + 1], start_goal_pos[(z - 180) * 4 + 0]),                                                 (start_goal_pos[(z - 180) * 4 + 3], start_goal_pos[(z - 180) * 4 + 2]),2,1.25)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 180) * 4 + 3], start_goal_pos[(z - 180) * 4 + 2]).f)                        elif (z < 200):                            astar = AsSeq(grid)                            frame = astar.search((start_goal_pos[(z - 190) * 4 + 1], start_goal_pos[(z - 190) * 4 + 0]),                                                 (start_goal_pos[(z - 190) * 4 + 3], start_goal_pos[(z - 190) * 4 + 2]),2,2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 190) * 4 + 3], start_goal_pos[(z - 190) * 4 + 2]).f)                        elif (z < 210):                            astar = AsQue(grid)                            frame = astar.search((start_goal_pos[(z - 200) * 4 + 1], start_goal_pos[(z - 200) * 4 + 0]),                                                 (start_goal_pos[(z - 200) * 4 + 3], start_goal_pos[(z - 200) * 4 + 2]),3,1.25)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 200) * 4 + 3], start_goal_pos[(z - 200) * 4 + 2]).f)                        elif (z < 220):                            astar = AsQue(grid)                            frame = astar.search((start_goal_pos[(z - 210) * 4 + 1], start_goal_pos[(z - 210) * 4 + 0]),                                                 (start_goal_pos[(z - 210) * 4 + 3], start_goal_pos[(z - 210) * 4 + 2]),3,2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 210) * 4 + 3], start_goal_pos[(z - 210) * 4 + 2]).f)                        elif (z < 230):                            astar = AsQue(grid)                            frame = astar.search((start_goal_pos[(z - 220) * 4 + 1], start_goal_pos[(z - 220) * 4 + 0]),                                                 (start_goal_pos[(z - 220) * 4 + 3], start_goal_pos[(z - 220) * 4 + 2]),2,1.25)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 220) * 4 + 3], start_goal_pos[(z - 220) * 4 + 2]).f)                        elif (z < 240):                            astar = AsQue(grid)                            frame = astar.search((start_goal_pos[(z - 230) * 4 + 1], start_goal_pos[(z - 230) * 4 + 0]),                                                 (start_goal_pos[(z - 230) * 4 + 3], start_goal_pos[(z - 230) * 4 + 2]),2,2)                            cell_length.append(                                astar.get_cell(start_goal_pos[(z - 230) * 4 + 3], start_goal_pos[(z - 230) * 4 + 2]).f)                        check = 1                        #result to store in output file                        duration_time = time.time()-start_time                        run_time.append(duration_time)                        node_expand.append(astar.getNodeExpand())                        memory_require.append(astar.getMemReq())                        print(z)                        # fill color based on 2d array                        for x in range(120):                            for y in range(160):                                if (frame[x][y] == 2):                                    color = GREY                                elif (frame[x][y] == 0):                                    color = DARK_GREY                                elif (frame[x][y] == 'a'):                                    color = BLUE                                elif (frame[x][y] == 'b'):                                    color = BLUE                                elif (frame[x][y] == 1):                                    color = WHITE                                elif (frame[x][y] == 'p'):                                    color = RED                                elif (frame[x][y] == 'q'):                                    color = RED                                elif (frame[x][y] == 'r'):                                    color = RED                                elif (frame[x][y] == 's'):                                    color = RED                                else:                                    continue                                make_grid_color(screen, color, y * 8, x * 8)                        pygame.display.flip()                elif(pos[0]>=0 and pos[0]<=1280 and pos[1]>=0 and pos[1]<=960):                    content = []                    content.append(int(astar.get_cell(int(pos[0]/8),int(pos[1]/8)).h))                    content.append(int(astar.get_cell(int(pos[0]/8),int(pos[1]/8)).g))                    content.append(int(astar.get_cell(int(pos[0]/8), int(pos[1]/8)).f))                    pos_font = pygame.font.SysFont("Comic Sans MS", 30)                    pos_text_surface = pos_font.render('h,g,f{}'.format(content), 1, (0, 0, 0))                    screen.blit(pos_text_surface, (1281, 500))                    pygame.display.update()                    pos_text_surface = pos_font.render('h,g,f{}'.format(content), 1, WHITE)                    screen.blit(pos_text_surface, (1281, 500))    print('end')    #clear file_frame    for x in range(120):        for y in range(160):            if (file_frame[x][y] == 'p'):                frame[x][y] = 1            elif (file_frame[x][y] == 'q'):                frame[x][y] = 2            elif (file_frame[x][y] == 'r'):                frame[x][y] = 'a'            elif (file_frame[x][y] == 's'):                frame[x][y] = 'b'            else:                continue    result_file.write(str(file_start_point))    result_file.write('\n')    result_file.write(str(file_end_point))    result_file.write('\n')    result_file.write(str(file_hard_to_traverse_point))    result_file.write('\n')    result_file.write(str(file_frame))    title_run_time = ['UCS','AsMan_1','AsMan_1.5','AsMan_2','AsCostMan_1','AsCostMan_1.5','AsCostMan_2','AsEu_1','AsEu_1.5','AsEu_2','AsME_1','AsME_1.5','AsME_2','AsDia_1','AsDia_1.5','AsDia_2','AsSeq_3_1.25','AsSeq_3_2','AsSeq_2_1.25','AsSeq_2_2','AsQue_3_1.25','AsQue_3_2','AsQue_2_1.25','AsQue_2_2']    time_file.write(str(title_run_time))    time_file.write('\n')    for i in range(24):        file_run_time.append((run_time[10*i+0]+run_time[10*i+1]+run_time[10*i+2]+run_time[10*i+3]+run_time[10*i+4]+run_time[10*i+5]+run_time[10*i+6]+run_time[10*i+7]+run_time[10*i+8]+run_time[10*i+9])/10)        #if(i>=13):            #file_run_time[i] = file_run_time[i]*number    time_file.write(str(file_run_time))    time_file.write('\n')    for i in range(24):        file_cell_length.append((cell_length[10*i+0]+cell_length[10*i+1]+cell_length[10*i+2]+cell_length[10*i+3]+cell_length[10*i+4]+cell_length[10*i+5]+cell_length[10*i+6]+cell_length[10*i+7]+cell_length[10*i+8]+cell_length[10*i+9])/10)    file_cell_length[1] = file_cell_length[0]    time_file.write(str(file_cell_length))    time_file.write('\n')    for i in range(24):        file_node_expand.append((node_expand[10*i+0]+node_expand[10*i+1]+node_expand[10*i+2]+node_expand[10*i+3]+node_expand[10*i+4]+node_expand[10*i+5]+node_expand[10*i+6]+node_expand[10*i+7]+node_expand[10*i+8]+node_expand[10*i+9])/10)    time_file.write(str(file_node_expand))    time_file.write('\n')    for i in range(24):        file_memory_require.append((memory_require[10*i+0]+memory_require[10*i+1]+memory_require[10*i+2]+memory_require[10*i+3]+memory_require[10*i+4]+memory_require[10*i+5]+memory_require[10*i+6]+memory_require[10*i+7]+memory_require[10*i+8]+memory_require[10*i+9])/10)    time_file.write(str(file_memory_require))    returndef make_grid_color(screen, color, width_pos,height_pos):    pygame.draw.rect(screen, color, (width_pos+1, height_pos+1, WIDTH-1, HEIGHT-1))    returndef init_start_goal_pos(frame):    start_goal_pos = []    for i in range(10):        count = 0        while(True):            pos = numpy.random.randint(19200)            y_pos = pos // 160            x_pos = pos - y_pos * 160            if((y_pos<=20 or y_pos>=100)and (x_pos<=20 or x_pos>=140)):                if(frame[y_pos][x_pos]!=0):                    start_goal_pos.append(y_pos)                    start_goal_pos.append(x_pos)                    count+=1                    if(count ==2):                        if(((start_goal_pos[i*4+2]-start_goal_pos[i*4+0])*(start_goal_pos[i*4+2]-start_goal_pos[i*4+0])+(start_goal_pos[i*4+3]-start_goal_pos[i*4+1])*(start_goal_pos[i*4+3]-start_goal_pos[i*4+1]))>=10000):                            break                        else:                            start_goal_pos.pop()                            start_goal_pos.pop()                            start_goal_pos.pop()                            start_goal_pos.pop()                            count = 0                            continue    return start_goal_posdef shape_frame(frame):    frame = make_part_block(frame)    frame = make_highway(frame)    frame = make_block(frame)    return frame# Use ’0’ to indicate a blocked cell# Use ’1’ to indicate a regular unblocked cell# Use ’2’ to indicate a hard to traverse cell# Use ’a’ to indicate a regular unblocked cell with a highway# Use ’b’ to indicate a hard to traverse cell with a highwaydef make_block(frame):    #random 3840 number    random_block = numpy.random.choice(19200,size=3840,replace = False)    for i in range(3840):        #get the x_pos and y_pos        y_pos = random_block[i]//160        x_pos = random_block[i]-y_pos*160        if(frame[int(y_pos)][int(x_pos)]==1):            frame[int(y_pos)][int(x_pos)]=0        else:            #regenerate number            while(frame[int(y_pos)][int(x_pos)]!=1):                random_block[i] = numpy.random.randint(19200)                y_pos = random_block[i] // 160                x_pos = random_block[i] -y_pos*160            frame[int(y_pos)][int(x_pos)] = 0    return framedef make_part_block(frame):    # 8 random 31*31 block area    y = numpy.random.randint(0, 119, 8)    x = numpy.random.randint(0, 159, 8)    #set write_hard_to_tarverse file    for i  in range(8):        file_hard_to_traverse_point.append([y[i], x[i]])    for i in range(8):        x_left = x[i] - 15        y_top = y[i] - 15        count_block = 0        start_count = 0        for a in range(31):            for b in range(31):                #if out-of-bound                if(y_top+a<0 or y_top+a>119 or x_left+b<0 or x_left+b>159):                    continue                else:                    # it is already block                    if (frame[y_top + a][x_left + b] == 0 and start_count == 0):                        count_block = count_block + 1                    else:                        frame[y_top + a][x_left + b] = numpy.random.randint(2)+1                        if (start_count == 1):                            count_block = count_block - 1                        if (count_block != 0 and a == 30):                            a = 0                            b = 0                            start_count = 1    return frame# Use ’0’ to indicate a blocked cell# Use ’1’ to indicate a regular unblocked cell# Use ’2’ to indicate a hard to traverse cell# Use ’a’ to indicate a regular unblocked cell with a highway# Use ’b’ to indicate a hard to traverse cell with a highwaydef make_highway(frame):    x_pos = [0,0,0,0]    y_pos = [0,0,0,0]    #random 4 start point    start_point = numpy.random.randint(0,555,4)    #convert start point    for i in range(4):        if(start_point[i]<120):            x_pos[i] = 0            y_pos[i] = start_point[i]        elif(start_point[i]<279 and start_point[i]>=120):            x_pos[i] = start_point[i]-120            y_pos[i] = 119        elif(start_point[i]<398 and start_point[i]>=279):            x_pos[i] = 159            y_pos[i] = start_point[i]-279        else:            x_pos[i] = start_point[i]-398            y_pos[i] = 0    i = 0    while(i<4):        #start to move horizontal or vertical        #4 condition        highway_memory = []        restart = 0        size = 0        turn = check_start_highway(x_pos[i],y_pos[i],frame) #check when second time reach        frame = go_turn(x_pos[i],y_pos[i],turn,frame)        highway_memory.extend([x_pos[i],y_pos[i],turn])        temp_xpos = x_pos[i]        temp_ypos = y_pos[i]        temp_xpos = set_xpos(temp_xpos,turn,20)        temp_ypos = set_ypos(temp_ypos,turn,20)        while(check_mid_block(temp_xpos,temp_ypos,turn,frame)!=-1 or size<100):            random_way = numpy.random.choice(3,1,replace = False,p=[0.6,0.2,0.2])            #0 is continue, 1 is turn right, 2 is turn left            turn = shape_turn(turn,random_way)            start_turn = turn            if(check_mid_block(temp_xpos,temp_ypos,turn,frame)==1):                frame = go_turn(temp_xpos,temp_ypos,turn,frame)                highway_memory.extend([temp_xpos, temp_ypos, turn])                size = size+20                temp_xpos = set_xpos(temp_xpos, turn, 20)                temp_ypos = set_ypos(temp_ypos, turn, 20)            elif(check_mid_block(temp_xpos,temp_ypos,turn,frame)==0):                if(random_way==0):                    random_way=1                elif(random_way==1):                    random_way=2                    turn = shape_turn(turn, random_way)                elif(random_way==2):                    random_way=1                turn = shape_turn(turn,random_way)                if(check_mid_block(temp_xpos,temp_ypos,turn,frame)==1):                    frame = go_turn(temp_xpos, temp_ypos, turn, frame)                    highway_memory.extend([temp_xpos, temp_ypos, turn])                    size = size + 20                    temp_xpos = set_xpos(temp_xpos, turn, 20)                    temp_ypos = set_ypos(temp_ypos, turn, 20)                elif(check_mid_block(temp_xpos,temp_ypos,turn,frame)==0):                    if (random_way == 1 and start_turn==turn):                        random_way=1                    elif (random_way == 1 and start_turn!=turn):                        random_way=2                        turn = shape_turn(turn, random_way)                    elif (random_way == 2):                        random_way=1                    turn = shape_turn(turn, random_way)                    if (check_mid_block(temp_xpos, temp_ypos, turn, frame) == 1):                        size = size + 20                        frame = go_turn(temp_xpos, temp_ypos, turn, frame)                        highway_memory.extend([temp_xpos, temp_ypos, turn])                        temp_xpos = set_xpos(temp_xpos, turn, 20)                        temp_ypos = set_ypos(temp_ypos, turn, 20)                    elif (check_mid_block(temp_xpos, temp_ypos, turn, frame) == 0):                        frame = clear_highway(highway_memory,frame)                        #init start point                        start_point = numpy.random.randint(0, 555)                        if (start_point < 120):                            x_pos[i] = 0                            y_pos[i] = start_point                        elif (start_point < 279 and start_point >= 120):                            x_pos[i] = start_point - 120                            y_pos[i] = 119                        elif (start_point < 398 and start_point >= 279):                            x_pos[i] = 159                            y_pos[i] = start_point - 279                        else:                            x_pos[i] = start_point - 398                            y_pos[i] = 0                        i=i-1                        restart = 1                        break            elif(check_mid_block(temp_xpos,temp_ypos,turn,frame)==-1):                if(size>=100):                    break                else:                    frame = clear_highway(highway_memory, frame)                    # init start point                    start_point = numpy.random.randint(0, 555)                    if (start_point < 120):                        x_pos[i] = 0                        y_pos[i] = start_point                    elif (start_point < 279 and start_point >= 120):                        x_pos[i] = start_point - 120                        y_pos[i] = 119                    elif (start_point < 398 and start_point >= 279):                        x_pos[i] = 159                        y_pos[i] = start_point - 279                    else:                        x_pos[i] = start_point - 398                        y_pos[i] = 0                    i = i - 1                    restart = 1                    break        #while end        if(restart==0):            #special case that two line clash            if(go_last_turn(temp_xpos,temp_ypos,turn,frame)==0):                frame = clear_highway(highway_memory, frame)                # init start point                start_point = numpy.random.randint(0, 555)                if (start_point < 120):                    x_pos[i] = 0                    y_pos[i] = start_point                elif (start_point < 279 and start_point >= 120):                    x_pos[i] = start_point - 120                    y_pos[i] = 119                elif (start_point < 398 and start_point >= 279):                    x_pos[i] = 159                    y_pos[i] = start_point - 279                else:                    x_pos[i] = start_point - 398                    y_pos[i] = 0                i = i - 1            else:                frame = go_last_turn(temp_xpos, temp_ypos, turn, frame)        i+=1    return framedef clear_highway(highway_memory,frame):    clear_group = len(highway_memory)/3    for a in range(int(clear_group)):        x_pos = highway_memory[3*a]        y_pos = highway_memory[3*a+1]        turn = highway_memory[3*a+2]        for i in range(20):            if (turn == 3):                if (frame[y_pos + i][x_pos] == 'b'):                    frame[y_pos + i][x_pos] = 2                else:                    frame[y_pos + i][x_pos] = 1            elif (turn == 4):                if (frame[y_pos - i][x_pos] == 'b'):                    frame[y_pos - i][x_pos] = 2                else:                    frame[y_pos - i][x_pos] = 1            elif (turn == 1):                if (frame[y_pos][x_pos + i] == 'b'):                    frame[y_pos][x_pos + i] = 2                else:                    frame[y_pos][x_pos + i] = 1            elif (turn == 2):                if (frame[y_pos][x_pos - i] == 'b'):                    frame[y_pos][x_pos - i] = 2                else:                    frame[y_pos][x_pos - i] = 1    return frame#return 1 is go right, 2 is go left, 3 is go bottom, 4 is go top# 1 is ok, 0 is a clashdef check_last_turn(x_pos,y_pos,turn,frame):    i = -1    while (True):        i = i + 1        if (turn == 3):            if (y_pos + i < 120):                if (frame[y_pos + i][x_pos] == 'a' or frame[y_pos + i][x_pos] == 'b'):                    return 0            else:                break        elif (turn == 4):            if (y_pos - i >= 0):                if (frame[y_pos - i][x_pos] == 'a' or frame[y_pos - i][x_pos] == 'b'):                    return 0            else:                break        elif (turn == 1):            if (x_pos + i < 160):                if (frame[y_pos][x_pos + i] == 'a' or frame[y_pos][x_pos + i] == 'b'):                    return 0            else:                break        elif (turn == 2):            if (x_pos - i >= 0):                if (frame[y_pos][x_pos - i] == 'a' or frame[y_pos][x_pos - i] == 'b'):                    return 0            else:                break    return 1#return 1 is go right, 2 is go left, 3 is go bottom, 4 is go topdef go_last_turn(x_pos,y_pos,turn,frame):    i=-1    while(True):        i = i+1        if (turn == 3):            if(y_pos+i<120):                if(frame[y_pos+i][x_pos]==2):                    frame[y_pos + i][x_pos] = 'b'                else:                    frame[y_pos + i][x_pos] = 'a'            else:                break        elif(turn == 4):            if(y_pos-i>=0):                if(frame[y_pos-i][x_pos]==2):                    frame[y_pos - i][x_pos] = 'b'                else:                    frame[y_pos - i][x_pos] = 'a'            else:                break        elif(turn == 1):            if(x_pos+i<160):                if (frame[y_pos][x_pos+i]==2):                    frame[y_pos][x_pos + i] = 'b'                else:                    frame[y_pos][x_pos + i] = 'a'            else:                break        elif (turn == 2):            if(x_pos-i>=0):                if (frame[y_pos][x_pos-i] == 2):                    frame[y_pos][x_pos - i] = 'b'                else:                    frame[y_pos][x_pos - i] = 'a'            else:                break    return frame#return 1 is go right, 2 is go left, 3 is go bottom, 4 is go topdef shape_turn(turn, random_way):    if(random_way==1):        if(turn==1):            return 3        elif(turn==2):            return 4        elif(turn==3):            return 2        elif(turn==4):            return 1    elif(random_way==2):        if (turn == 1):            return 4        elif (turn == 2):            return 3        elif (turn == 3):            return 1        elif (turn == 4):            return 2    return turn#return 1 is go right, 2 is go left, 3 is go bottom, 4 is go topdef check_start_highway(x_pos,y_pos,frame):    if(x_pos==0):        if(check_mid_block(x_pos,y_pos,1,frame)==1):            return 1        elif(check_mid_block(x_pos,y_pos,3,frame)==1):            return 3        elif (check_mid_block(x_pos, y_pos, 4, frame) == 1):            return 4    elif(x_pos==159):        if (check_mid_block(x_pos, y_pos, 2, frame) == 1):            return 2        elif (check_mid_block(x_pos, y_pos, 3, frame) == 1):            return 3        elif (check_mid_block(x_pos, y_pos, 4, frame) == 1):            return 4    elif (y_pos == 0):        if (check_mid_block(x_pos, y_pos, 3, frame) == 1):            return 3        elif (check_mid_block(x_pos, y_pos, 1, frame) == 1):            return 1        elif (check_mid_block(x_pos, y_pos, 2, frame) == 1):            return 2    elif (y_pos == 119):        if (check_mid_block(x_pos, y_pos, 4, frame) == 1):            return 4        elif (check_mid_block(x_pos, y_pos, 1, frame) == 1):            return 1        elif (check_mid_block(x_pos, y_pos, 2, frame) == 1):            return 2    return 0#return 1 is possible, 0 is no, -1 is to the enddef check_mid_block(x_pos,y_pos,turn,frame):    if (turn == 3):        if (y_pos+19>=119):            return -1    elif (turn == 4):        if (y_pos-19<=0):            return -1    elif (turn == 1):        if (x_pos+19>=159):            return -1    elif (turn == 2):        if (x_pos-19<=0):            return -1    for i in range(21):        if (turn == 3):            if(frame[y_pos+i][x_pos]=='a' or frame[y_pos+i][x_pos]=='b'):                return 0        elif(turn == 4):            if(frame[y_pos-i][x_pos]=='a' or frame[y_pos-i][x_pos]=='b'):                return 0        elif(turn == 1):            if (frame[y_pos][x_pos+i] == 'a' or frame[y_pos][x_pos+i] == 'b'):                return 0        elif (turn == 2):            if (frame[y_pos][x_pos-i] == 'a' or frame[y_pos][x_pos-i] == 'b'):                return 0    return 1#return 1 is go right, 2 is go left, 3 is go bottom, 4 is go topdef go_turn(x_pos,y_pos,turn,frame):    for i in range(20):        if (turn == 3):            if(frame[y_pos+i][x_pos]==0):                frame[y_pos + i][x_pos] = 'b'            else:                frame[y_pos + i][x_pos] = 'a'        elif(turn == 4):            if(frame[y_pos-i][x_pos]==0):                frame[y_pos - i][x_pos] = 'b'            else:                frame[y_pos - i][x_pos] = 'a'        elif(turn == 1):            if (frame[y_pos][x_pos+i]==0):                frame[y_pos][x_pos + i] = 'b'            else:                frame[y_pos][x_pos + i] = 'a'        elif (turn == 2):            if (frame[y_pos][x_pos-i] == 0):                frame[y_pos][x_pos - i] = 'b'            else:                frame[y_pos][x_pos - i] = 'a'    return framedef set_xpos(x_pos,turn,number_grid):    if(turn==1):        x_pos = x_pos+number_grid    elif(turn==2):        x_pos = x_pos-number_grid    return x_posdef set_ypos(y_pos,turn,number_grid):    if(turn==3):        y_pos = y_pos+number_grid    elif(turn==4):        y_pos = y_pos-number_grid    return y_pos